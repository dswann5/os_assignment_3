Daniel Swann and Jerald Liu
dswann5@jhu.edu and liu.jerald@gmail.com
Assignment 3



Part 1: Study, Design, Log

The process that wants to give up its CPU must acquire the ptable.lock, release any other locks it has, update its proc state and call sched(). Sched() checks for the previously mentioned conditions. Since the ptable lock is held, the CPU should be running w/interrups disabled. Sched() calls swtch() to save the current context in proc->context. Then we switch to the scheduler context given by cpu->scheduler. Swtch() returns on scheduler's stack as though scheduler's swtch had returned. The scheduler is infinitely looping to find a process to run and to switch to it. It finds a process that is RUNNABLE, sets proc, switches to the process' page table with switchuvm, marks the process as RUNNING, and finally calls swtch() to start running the new process.

Sleep() and wakeup() are used to prevent processes from having to continuously check whether a condition has been met that may be dependent on another process. A process will call sleep(), wait for the wakeup() call in another process, and will continue executing when it has been woken up. Sleep() takes an arbitrary channel argument that allows a process to sleep on a specific channel aka the "wait channel". It releases the CPU from the calling process to do other work for other processes. Wakeup() also takes a channel argument that wakes all processes sleeping on the channel, causing the sleep() calls to return.

Sleep() begins with sanity checks: there must be a current process, and sleep() must have been passed a lock. Sleep acquires the ptable.lock. The process going to sleep holds both the ptable.lock and lk. This is necessary in the caller to ensure no other process could start a call to wakeup(). Now that sleep holds the ptable.lock, it's safe to release lk. Some other process may start a call to wakeup(), but will not run until it can acquire the ptable.lock, so it must wait until sleep() has finished putting process to sleep(), keeping wakeup() from missing sleep(). If the lk is the same as the ptable.lock, then there would be a deadlock. Sleep() considers the acquire and release to cancel each other out, so it sleeps(). Now that the ptable.lock is held (and only the ptable.lock is held) sleep() can record the sleep channel, change proc state to SLEEPING, and call sched. Eventually a process calls wakeup(). Wakeup() acquires the ptable lock and calls wakeup1(). Since we are manipulating process state, we have to make sure that sleep() and wakeup() do not miss each other. When looping through processes, wakeup1() switches processes on the same channel that are SLEEPING to RUNNABLE. The scheduler will see that the process is ready to be run. Wakeup must be called holding a lock that prevents observation of whatever the wakeup condition is. Sleeping processes won't miss a wakeup as a result. At all times before a process checks the condition until after it sleeps, it holds either a lock on the condition or ptable.lock or both. Since wakeup() executes holding both locks, wakeup must execute either before the potential sleeper checks the condition, or after the potential sleeper has completed putting itself to sleep.

Part 2 Additions:
1) Minimize number of processes to examine
Maintain a cache of pointers of indeces of processes that have called sleep in order to excluisively check those processes upon calling wakeup(). We do this by maintaining one NPROC length array in proc.c that keeps track of sleeping processes. We will create a struct containing a pointer to a process, the channel the sleeping process is sleeping on, and a next pointer to another process. To keep track of individual channels, we plan on having the first instance of a process sleeping on a specific channel to act as a head of a linked list of other processes sleeping on the same channel. The next pointers would be set to the next available space in the array. 

2) Minimize number of machine instructions for which the process table lock must be held in wakeup()

Part 3 Additions:



Part 2:
  At first we wanted to maintain one array with linked lists of processes for specific channels, but we soon realized that knowing where empty cells are in the array is difficult to keep track of when we want to allocate a space in the array for another one of our proc containing structs. Instead we decided to change our plan to having a linked list of structs containing an array of sleeping processes sleeptable, a specific channel, a variable to keep track on number of processes within the array, and a pointer to the next channel.
  When calling sleep(), we want to look through our linked list of channels to see if there is a channel struct that we can put our current process in. We handle the edge case where our head is null. If we cannot find the appropriate channel, we create one at the head of our linked list for efficiency.
  In wakeup(), we look for the channel we're interested in, we set all the processes in its sleeptable to RUNNABLE, then we unlink the channel from the linked list since we're no longer interested in this channel. We make sure to kfree() the channel since we kalloc()'d to it.
  We are concerned since our worst case complexity is O(n^2). This is due to our assumption that number of channels is bounded by number of processes sleeping. So, in wakeup(), we search through n channels for the channel we want to wakeup processes on, then we go through the n processes in that channel's sleeptable to set them all to running. This is worse than the O(n) worst case for xv6's original implementation. We argue though that on the average case, our implementation will be faster since we avoid having to check the entire ptable for SLEEPING processes on a certain channel.
  Since processes can be killed without completing their execution, we must modify our data structure upon a process being killed. Within kill(), we can make use of the pid in order to look up the process's channel. We iterate over our linked list of channels to find the appropriate channel, find the process within the array, and shift all processes located at greater indices one to the left.

We assume:
- Number of channels is bound to number of processes that can be SLEEPING

Part 3:
